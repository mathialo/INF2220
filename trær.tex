

\section{Trær}
Et tre en et spesielt tilfelle av en rettet graf der hver node har inngrad 1 (med unntak av rota i treet). Vi ser på et eksempel:
\begin{figure}[H]
\caption{Et lite binært tre}
\label{fig:tre}
\centering
~\\
\begin{tikzpicture}[sibling distance=8em,
every node/.style = {shape=circle, draw, align=center}]

\node{r}
	child {node {a}
		child {node {b}}
	}
	child {node {c}
		child {node {d}
			child {node {e}}
			child {node {f}}
		}
		child {node {g}}
	};
\end{tikzpicture}
\end{figure}

\paragraph{Terminologi}~\\
Vi skal se litt på ord og uttrykk for trær. Gjennomgående bruker vi treet i figur \ref{fig:tre} som eksempel

I figuren blir nodene tegnet som rundinger. For å betegne relasjonen mellom nodene bruker vi ofte familierelasjoner. Vi sier at $ e $ og $ f $ er \textbf{søsken}, $ d $ er \textbf{forelder} til $ e $, og $ e $ er \textbf{barn} av $ d $. Vi kan også si at $ g $ er \textbf{onkel} til $ f $, men dette er mindre vanlig, da vi sjeldent har bruk for å snakke om \say{onkelnoder}. 

Nodene $ r, a, c $ og $ d $ kalles \textbf{indre noder}, det vil si at disse nodene har barn. Noder som ikke har noen barn kalles \textbf{løvnoder}

I figur \ref{fig:tre} er $ r $ \textbf{rotnoden}. Rota i treet er den eneste noden uten noen foreldre. Rota er derfor et naturlig startpunkt når vi skal søke eller traversere gjennom treet. 


\subsection{Binære søketrær}
Binære søketrær er trær med noen spesielle krav. Hver node kan ikke ha mer enn to barn, vi kaller dem ofte venstre og høyre barn. Venstre barn er alltid mindre enn noden selv, og høyre barn er alltid større enn noden. Dette gjør binære søketrær meget godt egnet for søking. 

\begin{teorem}
\label{teo:bintre}
Å sette inn, fjerne eller søke etter noder i et binært søketre har
\begin{enumerate}[i]
\item I beste fall $ O(\log n) $ tid
\item I verste fall $ O(n) $ tid
\end{enumerate}
\end{teorem}

Vi skal ikke bevise teorem \ref{teo:bintre} her\footnote{Det kan vises ved induksjon at høyden til et binært tre i beste fall er $ \log_2 n $}, men vi kan se på et eksempel som viser ytterpunktene. I figur \ref{fig:bintre} ser vi to forskjellige binære søketrær. I treet til venstre har vi et fint, balansert tre. Det er lett å se at høyden (og dermed antall operasjoner vi må gjøre for å komme til bunn i treet) er lik $ \lceil \log_2 n \rceil $ der $ n $ er antall noder i treet.

I treet til høyre har hver node kun ett barn. Vi har i praksis en lenkeliste. Hvis vi skal søke etter 4, må vi tråkke gjennom alle de andre nodene for å komme dit. 

\begin{figure}[H]
\caption{To eksempler på binære søketrær}
\label{fig:bintre}
\centering
~\\
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=3.5cm},
  level 2/.style={sibling distance=2.5cm},
  level 3/.style={sibling distance=1.5cm},
every node/.style = {shape=circle, draw, align=center}]

\node{8}
	child {node {4}
		child {node {2}}
		child {node {7}
			child {node {6}}
			child [missing]{}
		}
	}
	child {node {12}
		child {node {9}
			child [missing]{}
			child {node {11}}
		}
		child {node {15}
			child {node {13}}
			child {node {16}}
		}
	};
\end{tikzpicture}
$ \quad\quad $
\begin{tikzpicture}[level distance=1.5cm,sibling distance=2cm,
every node/.style = {shape=circle, draw, align=center}]

\node{1}
	child [missing] {}
	child {node {2}
		child [missing]{}
		child {node {3}
			child [missing]{}
			child {node {4}}
		}
	};
\end{tikzpicture}
\end{figure}




\paragraph{Innsetting}~\\
Når vi skal sette inn en node i et binært søketre starter vi i rota. Vi sammenligner verdien vi skal sette inn med verdien i rota. Hvis verdien vi setter inn er mindre enn rota går vil til venstre, er den større går vi til høyre. Hva som skjer ved likhet er opp til oss å bestemme, men vi må være konsekvente. Når vi kommer til en nullpeker kan vi sette denne pekeren til å peke på noden vi setter inn.

Vi kan implementere denne funksjonen rekursivt. I en ytre klasse kan vi skrive en skallfunksjon som kaller på rotas \verb|instert|-metode. Vi har en indre \verb|Node|-klasse med en rekursiv insertmetode. Den kan implementeres slik:
\javaimport{ex_bintree_insert.java}
~\\

\paragraph{Fjerning}~\\
Når vi skal fjerne en node fra et binært søketre har vi tre forskjellige situasjoner som vi må se på.

{\bfseries Noden har ingen barn} (løvnode). Denne situasjonen er ganske grei. Siden noden ikke har noen barn å forholde seg til er det bare å fjerne den fra treet.

{\bfseries Noden har ett barn}. For å fjerne en node $ a $ med ett barn kan vi ganske enkelt flytte pekeren fra foreldernoden til $ a $, til barnet til $ a $.

{\bfseries Noden har to barn}. Hvis noden vi skal fjerne har to barn
\javaimport{ex_bintree_remove.java}

\subsection{Rød-svarte trær}
Rødsvarte trær er binære søketrær med noen spesielle strukturkrav. Kravene er designet for å motkjempe skjevhet (som illustrert i figur \ref{fig:bintre}), og dermed minke kjøretid.

Vi deler nodene opp i to kategorier, røde og svarte. Vi følger noen bestemte regler på hvordan vi skal farge nodene, og fargen på nodene avgjør som vi må benytte oss av rotasjon eller ikke (se \ref{trerotasjon}). Fargen til en node er ikke statisk, den kan endres.

\begin{definisjon}
Et rød-svart tre er et binært søketre der hver node er
farget enten rød eller svart slik at:
\begin{enumerate}[i]
\item Roten er svart.
\item Hvis en node er rød, må barna være svarte.
\item Enhver vei fra en node til en null-peker må inneholde samme antall svarte noder.
\end{enumerate}
\end{definisjon}~\\



\subsection{B-trær}
\subsection{Rotasjon}
\label{trerotasjon}
\subsubsection{Zig}
\subsubsection{Zig-zag}