\section{\color{red}Sortering}
\subsection{Formaliteter}
\label{sort_form}
Før vi kan begynne å se på noen spesielle sorteringsalgoritmer må vi formalisere hva vi mener med sortering. Vi definerer sortering slik:

\begin{definisjon}
Anta at $ \{a_i\}_{i=0}^n $ er en liste av sammenlignbare elementer. Vi sier at $ \{a'_i\}_{i=0}^n $ er den tilhørende sorterte lista hvis følgende kriterier er oppfylt:
\begin{enumerate}[i]
\item $ a'_i \leq a'_{i+1} $ for alle $ i = 0, 1, ..., n-1 $
\item Alle elementene i $ \{a\} $ er med i $ \{a'\} $
\end{enumerate}
\end{definisjon}

Det andre kriteriet kan virke litt snodig, men uten det ville sortering vært veldig enkelt. Vi kunne i så fall bare generert en ny liste med elementer i sortert rekkefølge, og det første kriteriet ville vært oppfylt. Vi trenger derfor bevaringskriteriet. 

Med ``sammenlignbare'' mener vi at det finnes en måte å entydig bestemme om et element er større enn, mindre enn eller lik et annet element. Hvis vi skal sortere tall er jobben enkel: vi sammenligner numerisk verdi. Hvis vi skal sammenligne to tekststrenger er det ikke like opplagt hvordan vi skal gjøre det. Skal vi sortere alfabetisk? Etter lengde på ordet? I et sånt tilfelle er det opp til oss å velge et fornuftig sammenligningskriterie. Det er vilkårlig hvordan vi sammenligner to elementer, så lenge vi gjør det likt gjennom hele sorteringen. 


\subsection{\color{red}Noen algoritmer}
Vi skal nå se på noen konkrete sorteringsalgoritmer. Gjennomgående i alle eksempler vil vi sortere tall etter tallverdi, men som diskutert i \ref{sort_form} vil vi enkelt kunne tilpasse algoritmene til å sortere på andre kriterier. 


\subsubsection{\color{red}Boblesortering}
\label{bubble}
\textbf{Boblesortering} (\textbf{bubble/(sinking) sort})  er en veldig ineffektiv sorteringsalgoritme, og brukes derfor lite i den virkelige verden. 
Idéen bak er derimot forholdsvis enkel:
Vi parvis sammenligner naboer i lista, og bytter om plassene deres dersom de står på feil plass.

\paragraph*{Wikipedias utgave}
Wikipedias versjon av boblesortering er forskjellig fra den som er gjennomgått i forelesning.
Her flytter vi oss hele tiden oppover i lista, og begynner på nytt når vi har kommet til slutten.
Dette gjentas helt til lista er ferdig sortert.

\begin{eks} Sortering av (5 1 2 5 8) \newline
  \textbf{Første gjennomgang}
  \begin{align*}
    (\mathbf{5}~ \mathbf{1}~ 2~ 5~ 8) \rightarrow (\mathbf{1}\, \mathbf{5} ~ 2 ~ 5 ~ 8) &\quad \text{Bytter, siden 5 > 1} \\
    (1~ \mathbf{5}~ \mathbf{4}~ 2~ 8) \rightarrow (1 ~ \mathbf{4} ~ \mathbf{5} ~ 2 ~ 8) &\quad \text{Bytter, siden 5 > 4} \\
    (1~ 4~ \mathbf{5}~ \mathbf{2}~ 8) \rightarrow (1~ 4~ \mathbf{2}~ \mathbf{5}~ 8)     &\quad \text{Bytter, siden 5 > 2} \\
    (1~ 4~ 2~ \mathbf{5}~ \mathbf{8}) \rightarrow (1~ 4~ 2~ \mathbf{5}~ \mathbf{8})     &\quad \text{Bytter ikke, siden 5 < 8}
  \end{align*}
  Deretter går vil tilbake til start og gjentar prosessen, helt til vi har gått gjennom lista uten at noen elementer har byttet plass.
  I dette tilfellet kreves tre gjennomganger.
\end{eks}

\javaimport{bubbleSort.java}




\subsubsection{\color{red}Innstikksortering}
\subsubsection{\color{red}Tresortering}
\subsubsection{\color{red}Quicksort}
\label{quick}
\subsubsection{\color{red}Radix}
